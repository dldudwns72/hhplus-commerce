# 캐시(Cache) 란?

- 자주 사용되는 데이터나 값을 미리 복사해 놓는 임시 장소


| 저장 매체       | 지연 시간 (Latency) | 읽기 속도 (대략적) |
|-------------|-----------------|-------------|
| CPU L1 캐시   | ~0.5 ns         | ~1000 GB/s  |
| CPU L2 캐시   | ~7 ns           | ~500 GB/s   |
| CPU L3 캐시   | ~20 ns          | ~200 GB/s   |
| RAM (메모리)   | ~100 ns         | ~30-60 GB/s |
| SSD (NVMe)  | ~100 µs (마이크로초) | ~3-7 GB/s   |
| SSD (SATA)  | ~500 µs         | ~500 MB/s   |
| HDD (하드디스크) | ~10 ms          | ~100 MB/s   |


### 캐시를 왜 사용하는가?

- DB 데이터 조회와 같은 경우 Disk(SSD/HDD)에서 데이터를 가져와 조회 속도가 비교적 느리나, Memory 기반 데이터 조회는 Disk 대비 조회 속도가 매우 증가함
- DB가 많은 양의 작업이 있어 부하가 있을 시, 캐시를 이용한 빠른 조회 처리와 부하가 가는 작업을 나누어 처리할 수 있다

### 데이터 조회 시 CPU Cache 는 왜 사용하지 않는가?

- CPU Cache 는 매우 빠르나 사용할 수 있는 용량이 매우 적어 연산 작업 및 최적화 기능들을 수행하는데에 기능 초점이 맞추어져 있다.
- CPU 가 자동으로 관리하기 때문에 직접 데이터를 넣거나 뺄 수 없다

### Memory 기반 캐시는 언제 사용되는가?

- 변경이 자주 일어나지 않는 고정된 데이터에 조회가 많이 발생하는 데이터일 경우

## 캐싱(Caching) 이란?

- 자주 사용하는 데이터를 빠르게 접근할 수 있도록 메모리에 저장하는 기술

### 로컬 캐시(local_cache)

- **단일 서버 애플리케이션**에서 메모리(RAM)에 데이터를 저장하여 빠르게 조회하는데 사용되는 캐싱 기술
    - EX) Caffeine, Ehcache, ConcurrentHashMap 등
- 장점: Network I/O 작업이 필요하지 않아 속도가 매우 빠름
- 단점: 많은 캐시 사용 시 메모리 부족 (OOM) 문제 발생 가능, 서버 간 데이터 공유되지 않음

### 외부(글로벌) 캐시(external_cache, distributed_cache)

- **여러 서버(애플리케이션)** 에서 동일한 캐시 데이터를 공유할 수 있는 캐시 시스템
    - EX) Redis, Memcached
- 데이터 양은 많으나 자주 조회되는 데이터와 같은 경우 외부 캐시를 이용하여 DB 부하를 감소할 수 있다.
- 장점: 비교적 속도 빠름(Network I/O 비용 존재), 분산 환경에서 동일한 캐시 사용 가능
- 단점: 외부 캐시 서버가 필요하며, 구성이 비교적 복잡하다.

## 캐시 전략(Cache Strategy)

- 캐시를 어떻게 관리하고 사용할지에 대한 계획 및 방법

1. Cache Aside (Lazy Loading)

- 애플리케이션이 데이터를 캐시에서 조회하고, 캐시가 없으면 애플리케이션이 데이터를 DB 에서 로드하여 캐시에 저장하는 방식
    - Cache Miss 가 발생할 때 DB를 조회하므로, 초기 로딩 시 부담이 적으나 첫 번쨰 조회 시 DB 부하가 발생
- DB에 캐시로 미리 넣어주는 작업을 해줄 수 있다 (Cache Warming)
    - 조회할 떄 정합성을 보장하기 어려워 TTL 기반 관리가 필요
- repository.findById 와 같이 어플리케이션 에서 DB를 조회함.
- 사용될 수 있는 사례
    - Redis + Spring 환경에서 주로 사용된다.
    - 읽기 요청이 많고, 쓰기가 적은 경우 / 데이터 변경이 자주 일어나지 않아 TTL(Time-To_Live) 기반 캐시 관리가 가능한 경우
        - EX) 사용자 프로필, 상품 정보, 배너 등

2. Read Through

- Cache Miss 가 발생하였을 때, 캐시가 DB로 부터 데이터를 가져와 캐시에 저장한 후 애플리케이션에 반환
    - Cache Aside 와 다른점은 데이터를 관리하는 주체가 캐시라는 점이다.
- 첫번째 조회 시 Cache Miss 가 발생하며 데이터를 DB 에서 조회한다.
- Cache Aside 개념으로 충분하다 생각됨.. 
- 사용될 수 있는 사례
    - local cache 환경에서 주로 사용되는 전략
    - 자주 변경되는 데이터를 캐싱할 때

3. Write Through

- Cache 와 DB가 동시에 업데이트 되는 방식, 데이터가 **캐시와 DB에 항상 일관되도록 유지**할 수 있다.
- 데이터가 캐시에도 쓰이기(Write) 때문에 쓰기 작업 비용이 더 크다.
- 사용될 수 있는 사례
    - 데이터 변경이 자주 일어나지는 않지만, 정합성을 요구하는 기능에 적합할 것으로 생각
        - 사용자 프로필, 상품 정보 등

4. Write Behind (Write Back)

- 데이터를 캐시에 **먼저 저장**하고, 주기적으로 캐시에서 DB로 데이터를 저장하는 방식
- DB 부하를 줄일 수 있으나, 주기적으로 동기화가 되지 않을 경우 데이터 일관성 문제가 발생할 수 있다.
- 사용될 수 있는 사례
    - 데이터 생성이 자주 일어나지만 추후에 일괄로 DB에 저장해도 되는 기능에 적합할 것으로 생각
        - 활동 로그

5. Time-based Expiration (만료 시간 설정)

- 일정 시간이 지나면 캐시된 데이터를 자동으로 제거하는 방식, TTL(Time To Live) 설정
- TTL 만료 시 캐시에서 자동으로 삭제
- 만료 시간이 지나기 전에는 데이터가 유효하지만, 이후에는 정확성을 보장할 수 없다.
- 사용될 수 있는 사례
    - 데이터 정합성이 보장되진 않지만 주기적으로 정합성을 맞춰줄 수 있는 기능에 적합할 것으로 생각
        - 1시간 간격으로 업데이트되는 랭킹

6. Least Recently Used (LRU)

- 가장 오래전에 사용된 데이터를 가장 먼저 제거하는 방식
- 메모리 공간을 효율적으로 사용하고, 최신 데이터를 우선적으로 캐시합니다.
- 사용될 수 있는 사례
    - 웹 브라우저 캐시, 데이터베이스 연결 풀

7. Least Frequently Used (LFU)

- 가장 적게 사용된 데이터를 가장 먼저 제거하는 방식
- 사용될 수 있는 사례
    - 인기 게시글 캐싱, 검색결과 캐싱 

## 캐시 스탬피드(Cache Stampede) 현상

- 캐시가 만료 되엇을때, 여러 요청이 동시에 DB를 조회하여 부하가 폭증하는 현상

### 스탬피드 대응 정책

1. 캐시 리프레시

- 만료 전에 백그라운드 스레드가 미리 새로운 데이터를 가져와서 캐시에 갱신
- 읽기 요청을 처리하는 애플리케이션이 아닌, 별도의 스케줄러가 갱신을 담당

2. Double Cache (이중 캐싱)

- 메인 캐시가 만료되더라도, 백업 캐시에 오래된 데이터를 저장하여 응답 제공

3. 랜덤 만료 시간

- 만료 시간을 랜덤하게 설정하여 특정 시간에 모든 캐시가 만료되는 문제를 방지
- 지터 (Jitter) 시간 설정
  - 전자 신호를 읽는 과정에서 발생하는 짧은 지연 시간을 뜻하는 용어
  - 0~10 초 사이의 무작위 지연 시간을 추가할 경우, DB 의 부담이 10초에 걸쳐 분산 부하를 받게 된다.
- PER(Probabilistic Early Recomputation) 알고리즘
  - 유효 기간이 만료되기 전 일정 확률로 캐시를 재연산 하는 방식
  - 캐시 생성 소요 시간 기준 PER 알고리즘을 통한 랜덤한 만료시간 설정


###  E-Commerce 에서 캐시를 사용할 수 있는 사례

## 선착순 쿠폰
- 유저가 "선착순"을 보장 받으면서 쿠폰을 발급 받을 수 있는 기능인 선착순 쿠폰 기능에서 
시간을 score 으로 설정한 뒤 ZSet 자료구조를 통하여 선착순 보장 및 캐시를 이용한 발급을 할 수 있을 거라 생각됨

##  인기상품 조회
- 인기 상품 조회 시 주문 시 마다 주문을 조회하여 인기 상품을 조회하며 상품 정보를 가져오기에는 부하가 많이 걸릴 거라 생각되며, 
이에 대해 주문 시 상품에 대해 주문 수량 기준으로 Score 을 설정하고 해당 Score 기반 내림차순으로 인기상품 조회를 진행할 수 있다. 

## 상품 조회
- 상품과 연관된 브랜드 같이 무조건 조인이 이루어져야하는 데이터와 같은 경우 서버가 올라갈 떄 로컬 캐시에 저장하여 JOIN 에 대한 처리 속도를 향상 시킬 수 있다 
