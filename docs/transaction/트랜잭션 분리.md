# 개요

- 현재 사용하고 있는 모놀리식 구조에서 도메인별 모듈을 분리하고 관리하는 MSA(Micro Service Architecture) 환경으로 변경하게 될 떄 분산된 환경에서는 트랜잭션 처리의 한계가 있어 이에 대한
  처리는 어떻게 진행되는가에 대한 정리

## 분산환경에서의 트랜잭션 문제점

- 각 서비스가 독립적으로 배포되고 실행되기 때문에, 서비스 간 트랜잭션 처리는 기존의 모놀리식 구조에 비해 한계가 존재
    - 분산 환경으로 인해 트랜잭션의 특성인 ACID 를 보장할 수 없다.
    - 각 서비스 별 트랜잭션을 관리 필요

## 분산환경 트랜잭션 관리

  - 서비스 별로 나뉘어져 있는 트랜잭션을 관리해주기 위하여 트랜잭션 기능을 수행하는 보상 트랜잭션을 통하여 실제 트랜잭션의 동작 과 같이 멱등성이 보장 될 수 있도록 서비스 별 관리가 되어져야 함
  - 이를 관리하는 특정 패턴들이 존재

### 분산 환경 트랜잭션 관리 패턴

#### SAGA 패턴

  - 하나의 트랜잭션을 여러개의 로컬 트랜잭션으로 나누고, 각 서비스에서 로컬 트랜잭션 처리
      - 실패한 트랜잭션에 대해 보상 트랜잭션을 실행하여 상태를 복구 진행
  - Choreography 방식(서비스 간 이벤트로 진행)과 Orchestration 방식(중앙화된 관리자가 트랜잭션을 제어) 존재

#### 이벤트 기반 Choreography 방식

  - 이벤트 기반 SAGA 패턴에서는 메시징 시스템이나 애플리케이션 이벤트 리스너를 활용하여 서비스 간의 트랜잭션을 비동기적으로 처리합니다. 각 서비스가 이벤트를 발행하고, 다른 서비스는 이를 수신(subscribe)
    하여 처리하는 방식

1) 메시징 시스템을 사용하는 경우

   - 서비스 간의 트랜잭션 처리에서 비동기성과 내결함성을 쉽게 확보할 수 있습니다. Kafka 와 같은 시스템은 메시지 큐 역할을 하며, 이벤트를 지속적으로 전달하고, 실패한 메시지를 재처리할 수 있도록 도와줍니다.
   - 작동 방식 ( 주문 & 결제 방식 예시 )
       - 주문 생성 시 주문 완료 메세지 전송
       - 결제 서비스에서 주문 완료 이벤트를 구독하고, 결제 처리 작업 수행
       - 결제 서비스가 완료 되었다면 다시 이벤트를 발생 시킨 후 주문 성공 서비스가 이를 수신해서 주문 완료 처리 진행

2) 이벤트 처리 시스템을 사용하는 경우

   - Spring Framework 에서 제공하는 이벤트 처리 시스템인 ApplicationEventListener 을 사용하였을 떄 애플리케이션 내에서 이벤트를 발생시키고 리스너가 이를 수신하여 처리하는 방식입니다.
   - Spring Event 시스템을 활용하면 서비스 간의 통신을 애플리케이션 내부에서 쉽게 처리할 수 있습니다.
   - 작동 방식은 메세지 스템과 유사하나 어플리케이션 내에서 처리되는 점이 다름

#### 2PC (Two-Phase Commit)

  - 모든 참여자가 트랜잭션을 커밋할 준비가 되었는지 확인하고, 모든 서비스가 동의하면 커밋을 진행합니다. 하지만 이 방법은 장애 발생 시 시스템이 복잡해지기 때문에 사용에 주의 해야함
  - 트랜잭션의 일관성을 강력하게 보장하나, 장애 발생 시 복잡한 롤백과 대기 상태 발생

### SAGA 패턴을 이용한 주문&결제 트랜잭션 분리 시나리오

1. 주문 요청
2. 주문 생성 이벤트 발행

   - 주문 요청에 대한 API 응답

3. 주문 요청 이벤트 구독

   - 결제 완료 (외부 플랫폼 응답) 성공 시 결제 성공 이벤트 발행

4. 결제 성공 이벤트 구독

   - 유저 포인트 차감 성공 시 주문 성공 이벤트 발행
   - 유저 포인트 차감 실패 시 주문 실패 이벤트 발행

5. 주문 실패 이벤트 구독

   - 상품 재고 복구 기능 수행








